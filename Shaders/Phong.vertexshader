#version 330 core

// Input vertex data, different for all executions of this shader.
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec3 vertexNormal_modelspace;  // You will need this when you do lighting
layout(location = 2) in vec3 vertexColor; 
layout(location = 3) in vec2 vertexUV;

// output to Fragment Shader
out vec3 v_color;

out vec3 normal;          // Transformed normal in View Space
out vec3 eyeVector;       // Vector from the vertex to the Camera in View Space
out vec4 lightVector;     // Vector from the vertex to the Light in View Space
						  // Length of lightVector is the distance between light and vertex
out vec4 shadow_position; // Shadow's start point in camera space according to light's perspective.
out vec2 UV;

// Uniform
// Values that stay constant for the whole mesh. From Camera
uniform mat4 WorldTransform;
uniform mat4 ViewTransform;
uniform mat4 ProjectonTransform;
uniform mat4 correctedLightMVP;


// light position
uniform vec4 WorldLightPosition; // if w = 1: Point light, if w = 0: directional light


void main()
{
	// for use in the shader.
	
	mat4 MV = ViewTransform * WorldTransform;
	mat4 MVP = ProjectonTransform * MV;

	// Output position of the vertex, in clip space : MVP * position
	gl_Position =  MVP * vec4(vertexPosition_modelspace,1);

	UV = vertexUV;

	shadow_position;

	v_color = vertexColor;

	// Prepare Data for Fragment Shader
	// Should the normal be transformed?
	// yes, because we are working in camera space, so multiply by MV
	normal = vec3(MV * vec4(vertexNormal_modelspace, 0));

	
	// the vertex position in camera space.
	vec3 vertex_CameraSpace = vec3(MV * vec4(vertexPosition_modelspace, 1));

	// eye vector is from camera's location to the vertex we're looking at
	// Camera is at 0,0,0 in camera space.
	eyeVector = normalize(-vertex_CameraSpace);

	if(WorldLightPosition.w == 0){
		// directional, meaning WorldLightDirection is the direction vector, but only in world space, so convert to camera space
		lightVector = (ViewTransform * WorldLightPosition);
	} else {
		// point, meaning light goes in all directions, so light vector direction is from the point to the vertex
		lightVector = (ViewTransform * (WorldLightPosition - WorldTransform * vec4(vertexPosition_modelspace, 1)));
	}
}

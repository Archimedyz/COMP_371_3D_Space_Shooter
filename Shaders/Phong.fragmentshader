#version 330 core


// Light and Material Uniform Variables
uniform vec4 materialCoefficients; // x: ambient   y: diffuse   z: specular   w: specular exponent

uniform vec3 lightColor;
uniform vec3 lightAttenuation; // x: kC  y: kL  z: kQ

uniform sampler2DShadow shadowMap;

// Inputs
in vec3 v_color;		 // vertex color: also diffuse color

in vec3 normal;          // Transformed normal in View Space
in vec3 eyeVector;       // Vector from the vertex to the Camera in View Space
in vec4 lightVector;     // Vector from the vertex to the Light in View Space
						 // Length of lightVector is the distance between light and vertex
						 // if w = 1: Point light, if w = 0: directional light
in vec4 shadow_position; // the shadows start position relative to the camera.

// Ouput data
out vec3 color;


void main()
{
	// Implment Phong Shading based on the parameters above
	// Remember that directional light don't have attenuation
	
	float a_factor = 1.0f;
	
	vec3 normal_vector = normalize(normal);
	vec3 light_vector = normalize(vec3(lightVector));
	vec3 reflected_vector = 2.0f * dot(normal_vector, light_vector) * normal_vector - light_vector;
	vec3 eye_vector = normalize(eyeVector);

	float visibility = texture(shadowMap, vec3(shadow_position.x, shadow_position.y, (shadow_position.z/shadow_position.w)));
//	if(texture(shadowMap, vec3(shadow_position.x, shadow_position.y, (shadow_position.z/shadow_position.w))).z < shadow_position.z){
//		visibility = 0.2f;
//	}

	a_factor = 1.0f;
	if(lightVector.w == 1){
		// point, meaning light goes in all directions
		a_factor = 1.0f / ((lightAttenuation.x + lightAttenuation.y * length(vec3(lightVector)) + lightAttenuation.z * pow(lightAttenuation.z, 2)));
	}

	vec3 i_amb = v_color;
	vec3 i_light = a_factor * vec3(lightColor);

	float k_amb = materialCoefficients.x;
	float k_diff = materialCoefficients.y;
	float k_spec = materialCoefficients.z;
	float n_shiny = materialCoefficients.w;

	vec3 amb_intensity = lightColor * k_amb;
	vec3 diff_intensity = i_light * k_diff * clamp(dot(normal_vector, light_vector), 0.0f, 1.0f); 
	vec3 spec_intensity = i_light * k_spec * pow(clamp(dot(reflected_vector, eye_vector), 0.0f, 1.0f), n_shiny);

	vec3 total_intensity = amb_intensity + diff_intensity + spec_intensity;

	color = v_color * total_intensity;
}
